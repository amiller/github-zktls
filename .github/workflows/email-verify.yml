# Email Identity Verification
#
# Phase 2 of email verification. Triggered when someone comments on an
# [EMAIL] issue with the verification code from the email.
#
# The commenter doesn't need to be the email recipient — anyone (the
# notary, a bot, a friend) can paste the code. What matters is that
# sha256(code) matches the challenge_hash from Phase 1.
#
# Cross-references the Phase 1 bot comment to get challenge metadata,
# verifies the token, generates a certificate + ZK proof, and mints NFT.
#
# REQUIRED SECRETS:
#   - RELAYER_PRIVATE_KEY: funded wallet for gas

name: Email Verify

on:
  issue_comment:
    types: [created]

permissions:
  id-token: write
  contents: read
  attestations: write
  issues: write
  actions: read

jobs:
  verify-and-claim:
    if: >-
      contains(github.event.issue.title, '[EMAIL]') &&
      !contains(github.event.issue.title, '[EMAIL-VERIFY]') &&
      github.event.comment.user.login != 'github-actions[bot]'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Parse comment and cross-reference challenge
        id: meta
        uses: actions/github-script@v7
        with:
          script: |
            const token = (context.payload.comment.body || '').trim();

            if (!token || token.length < 32 || !/^[a-f0-9]+$/i.test(token)) {
              console.log('Comment is not a valid hex token, skipping.');
              core.setOutput('skip', 'true');
              return;
            }
            core.setOutput('skip', 'false');

            // Find the bot comment with challenge metadata
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const botComment = comments.data.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes('Challenge hash:')
            );
            if (!botComment) {
              core.setFailed('No challenge comment found on this issue');
              return;
            }

            const hashMatch = botComment.body.match(/Challenge hash: `([a-f0-9]{64})`/);
            const emailMatch = botComment.body.match(/Email: `(\S+@\S+\.\S+)`/);
            const recipientMatch = botComment.body.match(/Recipient: `(0x[a-fA-F0-9]{40})`/);
            const timestampMatch = botComment.body.match(/Timestamp: `([^`]+)`/);
            const runIdMatch = botComment.body.match(/Run ID: `(\d+)`/);

            if (!hashMatch || !emailMatch || !recipientMatch || !timestampMatch || !runIdMatch) {
              core.setFailed('Could not parse challenge metadata from bot comment');
              return;
            }

            // Verify Phase 1 workflow run: correct workflow file + same commit
            const challengeRunId = runIdMatch[1];
            const run = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: parseInt(challengeRunId)
            });

            const phase1 = run.data;
            if (phase1.status !== 'completed' || phase1.conclusion !== 'success') {
              core.setFailed(`Phase 1 run ${challengeRunId} did not succeed: ${phase1.conclusion}`);
              return;
            }
            if (!phase1.path.endsWith('email-challenge.yml')) {
              core.setFailed(`Phase 1 ran wrong workflow: ${phase1.path} (expected email-challenge.yml)`);
              return;
            }
            if (phase1.head_sha !== context.sha) {
              core.setFailed(`Phase 1 commit ${phase1.head_sha} !== Phase 2 commit ${context.sha}. Both must run at same commit.`);
              return;
            }
            console.log(`Phase 1 verified: run ${challengeRunId}, workflow ${phase1.path}, commit ${phase1.head_sha}`);

            // Check expiry (1 hour)
            const challengeTime = new Date(timestampMatch[1]);
            const elapsed = Date.now() - challengeTime.getTime();
            if (elapsed > 3600000) {
              core.setFailed('Challenge expired (>1 hour). Open a new [EMAIL] issue to try again.');
              return;
            }

            core.setOutput('challenge_hash', hashMatch[1]);
            core.setOutput('email', emailMatch[1]);
            core.setOutput('recipient', recipientMatch[1]);
            core.setOutput('token', token);
            console.log(`Email: ${emailMatch[1]}`);
            console.log(`Recipient: ${recipientMatch[1]}`);
            console.log(`Elapsed: ${Math.round(elapsed/1000)}s`);

      - name: Verify token
        if: steps.meta.outputs.skip != 'true'
        id: verify
        run: |
          TOKEN=$(echo -n "$TOKEN" | tr -d '[:space:]')
          HASH=$(echo -n "$TOKEN" | sha256sum | cut -d' ' -f1)

          echo "Expected: $EXPECTED_HASH"
          echo "Got:      $HASH"

          if [ "$HASH" != "$EXPECTED_HASH" ]; then
            echo "::error::Token does not match challenge hash"
            exit 1
          fi
          echo "Token verified!"
        env:
          TOKEN: ${{ steps.meta.outputs.token }}
          EXPECTED_HASH: ${{ steps.meta.outputs.challenge_hash }}

      - name: Generate certificate
        if: steps.meta.outputs.skip != 'true'
        run: |
          mkdir -p proof
          cat > proof/certificate.json << EOF
          {
            "type": "email-identity",
            "email": "${{ steps.meta.outputs.email }}",
            "recipient_address": "${{ steps.meta.outputs.recipient }}",
            "nft_contract": "${{ vars.EMAIL_NFT_ADDRESS }}",
            "chain_id": 84532,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "workflow_run": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF
          echo "Certificate:" && cat proof/certificate.json

      - name: Upload artifact
        if: steps.meta.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: email-proof
          path: proof/

      - name: Attest
        if: steps.meta.outputs.skip != 'true'
        id: attest
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: proof/certificate.json

      - name: Copy attestation bundle
        if: steps.meta.outputs.skip != 'true'
        run: cp ${{ steps.attest.outputs.bundle-path }} proof/bundle.json

      - name: Generate ZK proof
        if: steps.meta.outputs.skip != 'true'
        env:
          PROVER_DIGEST: sha256:b13465c5bc36840dc80a4cbfdc8d98abd51ae2abfdaa0d48edc4da872146e5f0
          EXPECTED_VK_HASH: "0x0d0b56f315c3dda7236c1d352fae8974871d3482125edea8a74139123d17d2fc"
        run: |
          REGISTRY="${{ vars.PROVER_REGISTRY || 'ghcr.io/amiller/zkproof' }}"
          echo "Using prover: ${REGISTRY}@${PROVER_DIGEST}"
          docker run --rm -e EXPECTED_VK_HASH="${EXPECTED_VK_HASH}" \
            -v ${{ github.workspace }}/proof:/work \
            "${REGISTRY}@${PROVER_DIGEST}" generate /work/bundle.json /work

      - name: Format claim data
        if: steps.meta.outputs.skip != 'true'
        id: claim
        run: |
          node -e "
            const fs = require('fs');
            const claim = JSON.parse(fs.readFileSync('proof/claim.json', 'utf8'));
            console.log('proof_hex=' + claim.proof);
            console.log('INPUTS=' + JSON.stringify(claim.inputs));
            console.log('CERT_HEX=0x' + Buffer.from(claim.certificate, 'utf8').toString('hex'));
            const cert = JSON.parse(claim.certificate);
            console.log('EMAIL=' + cert.email);
            console.log('RECIPIENT=' + cert.recipient_address);
          " >> "$GITHUB_OUTPUT"

      - name: Install Foundry
        if: steps.meta.outputs.skip != 'true'
        uses: foundry-rs/foundry-toolchain@v1

      - name: Submit claim transaction
        if: steps.meta.outputs.skip != 'true'
        id: submit
        env:
          RELAYER_KEY: ${{ secrets.RELAYER_PRIVATE_KEY }}
        run: |
          INPUTS='${{ steps.claim.outputs.INPUTS }}'
          INPUTS_FORMATTED=$(echo "$INPUTS" | jq -r 'join(",")')

          NFT_CONTRACT="${{ vars.EMAIL_NFT_ADDRESS }}"
          echo "Submitting claim to EmailNFT at $NFT_CONTRACT..."

          set +e
          OUTPUT=$(cast send \
            "$NFT_CONTRACT" \
            "claim(bytes,bytes32[],bytes,string,address)" \
            "${{ steps.claim.outputs.proof_hex }}" \
            "[$INPUTS_FORMATTED]" \
            "${{ steps.claim.outputs.CERT_HEX }}" \
            "${{ steps.claim.outputs.EMAIL }}" \
            "${{ steps.claim.outputs.RECIPIENT }}" \
            --private-key "$RELAYER_KEY" \
            --rpc-url https://sepolia.base.org \
            --gas-limit 3500000 \
            --json 2>&1)
          EXIT_CODE=$?
          set -e

          if [ $EXIT_CODE -ne 0 ]; then
            REASON=$(echo "$OUTPUT" | grep -oP 'Error\("\K[^"]+' || echo "$OUTPUT" | head -1)
            echo "error_reason=$REASON" >> $GITHUB_OUTPUT
            echo "Transaction failed: $REASON"
            exit 1
          fi

          TX_HASH=$(echo "$OUTPUT" | jq -r '.transactionHash')
          echo "tx_hash=$TX_HASH" >> $GITHUB_OUTPUT
          echo "Transaction submitted: $TX_HASH"

      - name: Comment success
        if: success() && steps.meta.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const txHash = '${{ steps.submit.outputs.tx_hash }}';
            const email = '${{ steps.meta.outputs.email }}';
            const recipient = '${{ steps.meta.outputs.recipient }}';

            const successMsg = [
              `## ✅ Email Verified — NFT Minted!`,
              ``,
              `**Email:** \`${email}\``,
              `**Recipient:** \`${recipient}\``,
              `**Transaction:** [${txHash}](https://sepolia.basescan.org/tx/${txHash})`,
              ``,
              `Your Email Identity NFT has been minted on Base Sepolia.`
            ].join('\n');

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: successMsg
            });
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['email-claimed']
            });

      - name: Comment failure
        if: failure() && steps.meta.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const step = '${{ steps.verify.outcome }}' === 'failure' ? 'token verification'
              : '${{ steps.submit.outcome }}' === 'failure' ? 'claim submission'
              : 'proof generation';
            const errorReason = '${{ steps.submit.outputs.error_reason }}' || 'See workflow logs';

            const failMsg = [
              `## ❌ Verification Failed`,
              ``,
              `**Step:** ${step}`,
              `**Reason:** ${errorReason}`,
              ``,
              `[View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            ].join('\n');

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: failMsg
            });
