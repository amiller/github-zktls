# Email Identity Verification
#
# Phase 2 of email verification. Triggered when a user clicks the magic
# link in their email, which opens a new issue with title [EMAIL-VERIFY]
# and the token as the body.
#
# Cross-references the original [EMAIL] issue to get challenge metadata,
# verifies the token, generates a certificate + ZK proof, and mints NFT.
#
# REQUIRED SECRETS:
#   - RELAYER_PRIVATE_KEY: funded wallet for gas

name: Email Verify

on:
  issues:
    types: [opened]

permissions:
  id-token: write
  contents: read
  attestations: write
  issues: write
  actions: read

jobs:
  verify-and-claim:
    if: contains(github.event.issue.title, '[EMAIL-VERIFY]')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Parse verify issue and cross-reference original
        id: meta
        uses: actions/github-script@v7
        with:
          script: |
            const title = context.payload.issue.title;
            const token = (context.payload.issue.body || '').trim();

            // Extract original issue number from title: [EMAIL-VERIFY] #123
            const issueMatch = title.match(/#(\d+)/);
            if (!issueMatch) {
              core.setFailed('Could not find original issue reference in title (expected [EMAIL-VERIFY] #NNN)');
              return;
            }
            const originalIssueNum = parseInt(issueMatch[1]);

            if (!token || token.length < 32) {
              core.setFailed('Invalid or missing token in issue body');
              return;
            }

            // Fetch the original issue's comments to find challenge metadata
            const comments = await github.rest.issues.listComments({
              issue_number: originalIssueNum,
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const botComment = comments.data.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes('Challenge hash:')
            );
            if (!botComment) {
              core.setFailed(`No challenge comment found on issue #${originalIssueNum}`);
              return;
            }

            // Extract metadata from the original issue's bot comment
            const hashMatch = botComment.body.match(/Challenge hash: `([a-f0-9]{64})`/);
            const emailMatch = botComment.body.match(/Email: `(\S+@\S+\.\S+)`/);
            const recipientMatch = botComment.body.match(/Recipient: `(0x[a-fA-F0-9]{40})`/);
            const timestampMatch = botComment.body.match(/Timestamp: `([^`]+)`/);
            const runIdMatch = botComment.body.match(/Run ID: `(\d+)`/);

            if (!hashMatch || !emailMatch || !recipientMatch || !timestampMatch || !runIdMatch) {
              core.setFailed('Could not parse challenge metadata from original issue');
              return;
            }

            // Verify Phase 1 workflow run: correct workflow file + same commit
            const challengeRunId = runIdMatch[1];
            const run = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: parseInt(challengeRunId)
            });

            const phase1 = run.data;
            if (phase1.status !== 'completed' || phase1.conclusion !== 'success') {
              core.setFailed(`Phase 1 run ${challengeRunId} did not succeed: ${phase1.conclusion}`);
              return;
            }
            if (!phase1.path.endsWith('email-challenge.yml')) {
              core.setFailed(`Phase 1 ran wrong workflow: ${phase1.path} (expected email-challenge.yml)`);
              return;
            }
            if (phase1.head_sha !== context.sha) {
              core.setFailed(`Phase 1 commit ${phase1.head_sha} !== Phase 2 commit ${context.sha}. Both must run at same commit.`);
              return;
            }
            console.log(`Phase 1 verified: run ${challengeRunId}, workflow ${phase1.path}, commit ${phase1.head_sha}`);

            // Check expiry (1 hour)
            const challengeTime = new Date(timestampMatch[1]);
            const elapsed = Date.now() - challengeTime.getTime();
            if (elapsed > 3600000) {
              core.setFailed('Challenge expired (>1 hour). Open a new [EMAIL] issue to try again.');
              return;
            }

            core.setOutput('challenge_hash', hashMatch[1]);
            core.setOutput('email', emailMatch[1]);
            core.setOutput('recipient', recipientMatch[1]);
            core.setOutput('token', token);
            core.setOutput('original_issue', originalIssueNum.toString());
            console.log(`Email: ${emailMatch[1]}`);
            console.log(`Recipient: ${recipientMatch[1]}`);
            console.log(`Original issue: #${originalIssueNum}`);
            console.log(`Elapsed: ${Math.round(elapsed/1000)}s`);

      - name: Verify token
        id: verify
        run: |
          TOKEN=$(echo -n "$TOKEN" | tr -d '[:space:]')
          HASH=$(echo -n "$TOKEN" | sha256sum | cut -d' ' -f1)

          echo "Expected: $EXPECTED_HASH"
          echo "Got:      $HASH"

          if [ "$HASH" != "$EXPECTED_HASH" ]; then
            echo "::error::Token does not match challenge hash"
            exit 1
          fi
          echo "Token verified!"
        env:
          TOKEN: ${{ steps.meta.outputs.token }}
          EXPECTED_HASH: ${{ steps.meta.outputs.challenge_hash }}

      - name: Generate certificate
        run: |
          mkdir -p proof
          cat > proof/certificate.json << EOF
          {
            "type": "email-identity",
            "email": "${{ steps.meta.outputs.email }}",
            "recipient_address": "${{ steps.meta.outputs.recipient }}",
            "nft_contract": "${{ vars.EMAIL_NFT_ADDRESS }}",
            "chain_id": 84532,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "workflow_run": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF
          echo "Certificate:" && cat proof/certificate.json

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: email-proof
          path: proof/

      - name: Attest
        id: attest
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: proof/certificate.json

      - name: Install nargo
        run: |
          curl -L https://raw.githubusercontent.com/noir-lang/noirup/main/install | bash
          /root/.nargo/bin/noirup -v 1.0.0-beta.17 || ~/.nargo/bin/noirup -v 1.0.0-beta.17
          echo "$HOME/.nargo/bin" >> $GITHUB_PATH

      - name: Install barretenberg
        run: |
          curl -L -o /tmp/bb.tar.gz \
            "https://github.com/AztecProtocol/aztec-packages/releases/download/v3.0.3/barretenberg-amd64-linux.tar.gz"
          sudo tar -xzf /tmp/bb.tar.gz -C /usr/local/bin
          sudo chmod +x /usr/local/bin/bb

      - name: Build prover
        run: |
          cd zk-proof/js && npm install && npx tsc
          cd ../circuits && nargo compile

      - name: Fetch attestation bundle
        run: |
          if [ -f "${{ steps.attest.outputs.bundle-path }}" ]; then
            cp "${{ steps.attest.outputs.bundle-path }}" proof/bundle.json
          else
            gh attestation download proof/certificate.json -R "${{ github.repository }}" -o proof/
            mv proof/*.jsonl proof/bundle.json 2>/dev/null || true
          fi
          echo "Bundle:" && ls -la proof/bundle.json
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Generate witness
        run: |
          cd zk-proof/js
          node dist/index.js witness "$(pwd)/../../proof/bundle.json"

      - name: Generate proof
        run: |
          cd zk-proof/circuits
          nargo execute
          bb write_vk -b target/zk_github_attestation.json -o target/vk -t evm
          bb prove \
            -b target/zk_github_attestation.json \
            -w target/zk_github_attestation.gz \
            -k target/vk/vk \
            -o target/proof \
            -t evm
          bb verify \
            -k target/vk/vk \
            -p target/proof/proof \
            -i target/proof/public_inputs \
            -t evm
          echo "Proof verified locally!"

      - name: Format claim data
        id: claim
        run: |
          cd zk-proof/circuits
          PROOF_HEX="0x$(xxd -p -c 99999 target/proof/proof)"

          node -e "
            const fs = require('fs');
            const raw = fs.readFileSync('target/proof/public_inputs');
            const inputs = [];
            for (let i = 0; i < raw.length; i += 32) {
              inputs.push('0x' + raw.slice(i, i + 32).toString('hex'));
            }
            const cert = fs.readFileSync('../../proof/certificate.json', 'utf8');
            const certJson = JSON.parse(cert);
            console.log('INPUTS=' + JSON.stringify(inputs));
            console.log('CERT_HEX=0x' + Buffer.from(cert, 'utf8').toString('hex'));
            console.log('EMAIL=' + certJson.email);
            console.log('RECIPIENT=' + certJson.recipient_address);
          " >> "$GITHUB_OUTPUT"

          echo "proof_hex=$PROOF_HEX" >> "$GITHUB_OUTPUT"

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Submit claim transaction
        id: submit
        env:
          RELAYER_KEY: ${{ secrets.RELAYER_PRIVATE_KEY }}
        run: |
          INPUTS='${{ steps.claim.outputs.INPUTS }}'
          INPUTS_FORMATTED=$(echo "$INPUTS" | jq -r 'join(",")')

          NFT_CONTRACT="${{ vars.EMAIL_NFT_ADDRESS }}"
          echo "Submitting claim to EmailNFT at $NFT_CONTRACT..."

          set +e
          OUTPUT=$(cast send \
            "$NFT_CONTRACT" \
            "claim(bytes,bytes32[],bytes,string,address)" \
            "${{ steps.claim.outputs.proof_hex }}" \
            "[$INPUTS_FORMATTED]" \
            "${{ steps.claim.outputs.CERT_HEX }}" \
            "${{ steps.claim.outputs.EMAIL }}" \
            "${{ steps.claim.outputs.RECIPIENT }}" \
            --private-key "$RELAYER_KEY" \
            --rpc-url https://sepolia.base.org \
            --json 2>&1)
          EXIT_CODE=$?
          set -e

          if [ $EXIT_CODE -ne 0 ]; then
            REASON=$(echo "$OUTPUT" | grep -oP 'Error\("\K[^"]+' || echo "$OUTPUT" | head -1)
            echo "error_reason=$REASON" >> $GITHUB_OUTPUT
            echo "Transaction failed: $REASON"
            exit 1
          fi

          TX_HASH=$(echo "$OUTPUT" | jq -r '.transactionHash')
          echo "tx_hash=$TX_HASH" >> $GITHUB_OUTPUT
          echo "Transaction submitted: $TX_HASH"

      - name: Comment success on original issue
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const txHash = '${{ steps.submit.outputs.tx_hash }}';
            const email = '${{ steps.meta.outputs.email }}';
            const recipient = '${{ steps.meta.outputs.recipient }}';
            const originalIssue = parseInt('${{ steps.meta.outputs.original_issue }}');

            const successMsg = [
              `## ✅ Email Verified — NFT Minted!`,
              ``,
              `**Email:** \`${email}\``,
              `**Recipient:** \`${recipient}\``,
              `**Transaction:** [${txHash}](https://sepolia.basescan.org/tx/${txHash})`,
              ``,
              `Your Email Identity NFT has been minted on Base Sepolia.`
            ].join('\n');

            // Comment on original [EMAIL] issue
            await github.rest.issues.createComment({
              issue_number: originalIssue,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: successMsg
            });
            await github.rest.issues.update({
              issue_number: originalIssue,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['email-claimed']
            });

            // Close this verify issue too
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['email-verified']
            });

      - name: Comment failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const step = '${{ steps.verify.outcome }}' === 'failure' ? 'token verification'
              : '${{ steps.submit.outcome }}' === 'failure' ? 'claim submission'
              : 'proof generation';
            const errorReason = '${{ steps.submit.outputs.error_reason }}' || 'See workflow logs';
            const originalIssue = parseInt('${{ steps.meta.outputs.original_issue }}') || null;

            const failMsg = [
              `## ❌ Verification Failed`,
              ``,
              `**Step:** ${step}`,
              `**Reason:** ${errorReason}`,
              ``,
              `[View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            ].join('\n');

            // Comment on this verify issue
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: failMsg
            });

            // Also comment on original issue if we have it
            if (originalIssue) {
              await github.rest.issues.createComment({
                issue_number: originalIssue,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: failMsg
              });
            }
