# Faucet Claim Relayer
#
# Triggered when someone opens an issue with [CLAIM] in the title.
# Parses proof data from issue body, submits tx, comments result.
#
# REQUIREMENTS:
#   - RELAYER_PRIVATE_KEY secret: funded wallet for gas
#   - Faucet contract must be deployed on Base Sepolia

name: Process Faucet Claim

on:
  issues:
    types: [opened]

permissions:
  issues: write

jobs:
  process-claim:
    if: contains(github.event.issue.title, '[CLAIM]')
    runs-on: ubuntu-latest
    steps:
      - name: Parse claim data
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';

            // Extract JSON from code block
            const jsonMatch = body.match(/```json\s*([\s\S]*?)\s*```/);
            if (!jsonMatch) {
              core.setFailed('No JSON code block found in issue body');
              return;
            }

            let claim;
            try {
              claim = JSON.parse(jsonMatch[1]);
            } catch (e) {
              core.setFailed(`Invalid JSON: ${e.message}`);
              return;
            }

            // Validate required fields
            const required = ['proof', 'inputs', 'certificate', 'username', 'recipient'];
            for (const field of required) {
              if (!claim[field]) {
                core.setFailed(`Missing required field: ${field}`);
                return;
              }
            }

            // Validate address format
            if (!/^0x[a-fA-F0-9]{40}$/.test(claim.recipient)) {
              core.setFailed('Invalid recipient address format');
              return;
            }

            // Validate proof is hex
            if (!/^0x[a-fA-F0-9]+$/.test(claim.proof)) {
              core.setFailed('Invalid proof format (must be hex)');
              return;
            }

            // Validate inputs is array of bytes32
            if (!Array.isArray(claim.inputs)) {
              core.setFailed('inputs must be an array');
              return;
            }

            // Validate username is a string
            if (typeof claim.username !== 'string' || claim.username.length === 0) {
              core.setFailed('username must be a non-empty string');
              return;
            }

            // Convert certificate to hex-encoded bytes for cast
            const certString = typeof claim.certificate === 'string'
              ? claim.certificate
              : JSON.stringify(claim.certificate);
            const certHex = '0x' + Buffer.from(certString, 'utf8').toString('hex');

            core.setOutput('proof', claim.proof);
            core.setOutput('inputs', JSON.stringify(claim.inputs));
            core.setOutput('certificate', certHex);
            core.setOutput('username', claim.username);
            core.setOutput('recipient', claim.recipient);
            core.setOutput('faucet', claim.faucet || '0xf31768d4E42d5e80aE95415309D7908ae730Fb41');

            console.log('Parsed claim:');
            console.log(`  Username: ${claim.username}`);
            console.log(`  Recipient: ${claim.recipient}`);
            console.log(`  Faucet: ${claim.faucet || 'default'}`);
            console.log(`  Proof length: ${claim.proof.length} chars`);
            console.log(`  Inputs count: ${claim.inputs.length}`);
            console.log(`  Certificate: ${certString.length} chars -> ${certHex.length} hex chars`);

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Submit claim transaction
        id: submit
        env:
          RELAYER_KEY: ${{ secrets.RELAYER_PRIVATE_KEY }}
        run: |
          # Format inputs as Solidity array
          INPUTS='${{ steps.parse.outputs.inputs }}'
          INPUTS_FORMATTED=$(echo "$INPUTS" | jq -r 'join(",")')

          echo "Submitting claim to faucet..."
          echo "Username: ${{ steps.parse.outputs.username }}"

          set +e
          OUTPUT=$(cast send \
            ${{ steps.parse.outputs.faucet }} \
            "claim(bytes,bytes32[],bytes,string,address)" \
            "${{ steps.parse.outputs.proof }}" \
            "[$INPUTS_FORMATTED]" \
            "${{ steps.parse.outputs.certificate }}" \
            "${{ steps.parse.outputs.username }}" \
            "${{ steps.parse.outputs.recipient }}" \
            --private-key "$RELAYER_KEY" \
            --rpc-url https://sepolia.base.org \
            --json 2>&1)
          EXIT_CODE=$?
          set -e

          if [ $EXIT_CODE -ne 0 ]; then
            echo "Cast output:"
            echo "$OUTPUT"
            # Extract revert reason if present
            REASON=$(echo "$OUTPUT" | grep -oP 'Error\("\K[^"]+' || echo "$OUTPUT" | head -1)
            echo "error_reason=$REASON" >> $GITHUB_OUTPUT
            echo "Transaction failed: $REASON"
            exit 1
          fi

          TX_HASH=$(echo "$OUTPUT" | jq -r '.transactionHash')
          echo "tx_hash=$TX_HASH" >> $GITHUB_OUTPUT
          echo "Transaction submitted: $TX_HASH"

      - name: Comment success
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const txHash = '${{ steps.submit.outputs.tx_hash }}';
            const recipient = '${{ steps.parse.outputs.recipient }}';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ✅ Claim Successful!\n\n` +
                    `**Recipient:** \`${recipient}\`\n` +
                    `**Transaction:** [${txHash}](https://sepolia.basescan.org/tx/${txHash})\n\n` +
                    `Funds should arrive shortly.`
            });

            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['claimed']
            });

      - name: Comment failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const errorReason = '${{ steps.submit.outputs.error_reason }}' || 'Unknown';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ❌ Claim Failed\n\n` +
                    `**Reason:** ${errorReason}\n\n` +
                    `[View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            });

            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['failed']
            });
