{"abi":[{"type":"function","name":"assertExists","inputs":[{"name":"self","type":"tuple","internalType":"struct Variable","components":[{"name":"ty","type":"tuple","internalType":"struct Type","components":[{"name":"kind","type":"TypeKind","internalType":"enum TypeKind"},{"name":"isArray","type":"bool","internalType":"bool"}]},{"name":"data","type":"bytes","internalType":"bytes"}]}],"outputs":[],"stateMutability":"pure"},{"type":"error","name":"NotInitialized","inputs":[]},{"type":"error","name":"TypeMismatch","inputs":[{"name":"expected","type":"string","internalType":"string"},{"name":"actual","type":"string","internalType":"string"}]},{"type":"error","name":"UnsafeCast","inputs":[{"name":"message","type":"string","internalType":"string"}]}],"bytecode":{"object":"0x610245610034600b8282823980515f1a607314602857634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610034575f3560e01c806315af8fee14610038575b5f5ffd5b61004b610046366004610148565b61004d565b005b5f8151516007811115610062576100626101fb565b03610080576040516321c4e35760e21b815260040160405180910390fd5b50565b634e487b7160e01b5f52604160045260245ffd5b604080519081016001600160401b03811182821017156100b9576100b9610083565b60405290565b5f82601f8301126100ce575f5ffd5b81356001600160401b038111156100e7576100e7610083565b604051601f8201601f19908116603f011681016001600160401b038111828210171561011557610115610083565b60405281815283820160200185101561012c575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60208284031215610158575f5ffd5b81356001600160401b0381111561016d575f5ffd5b8201808403606081121561017f575f5ffd5b610187610097565b6040821215610194575f5ffd5b61019c610097565b91508235600881106101ac575f5ffd5b8252602083013580151581146101c0575f5ffd5b60208301529081526040820135906001600160401b038211156101e1575f5ffd5b6101ed868385016100bf565b602082015295945050505050565b634e487b7160e01b5f52602160045260245ffdfea26469706673582212205e3b9890ae03d39d1600c7e00d6e4d98fd42d2822702b83030db870159aa17cc64736f6c634300081e0033","sourceMap":"1705:16281:4:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1705:16281:4;;;;;;;;;;;;;;;;;","linkReferences":{}},"deployedBytecode":{"object":"0x7300000000000000000000000000000000000000003014608060405260043610610034575f3560e01c806315af8fee14610038575b5f5ffd5b61004b610046366004610148565b61004d565b005b5f8151516007811115610062576100626101fb565b03610080576040516321c4e35760e21b815260040160405180910390fd5b50565b634e487b7160e01b5f52604160045260245ffd5b604080519081016001600160401b03811182821017156100b9576100b9610083565b60405290565b5f82601f8301126100ce575f5ffd5b81356001600160401b038111156100e7576100e7610083565b604051601f8201601f19908116603f011681016001600160401b038111828210171561011557610115610083565b60405281815283820160200185101561012c575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60208284031215610158575f5ffd5b81356001600160401b0381111561016d575f5ffd5b8201808403606081121561017f575f5ffd5b610187610097565b6040821215610194575f5ffd5b61019c610097565b91508235600881106101ac575f5ffd5b8252602083013580151581146101c0575f5ffd5b60208301529081526040820135906001600160401b038211156101e1575f5ffd5b6101ed868385016100bf565b602082015295945050505050565b634e487b7160e01b5f52602160045260245ffdfea26469706673582212205e3b9890ae03d39d1600c7e00d6e4d98fd42d2822702b83030db870159aa17cc64736f6c634300081e0033","sourceMap":"1705:16281:4:-:0;;;;;;;;;;;;;;;;;;;;;;;;4357:155;;;;;;:::i;:::-;;:::i;:::-;;;4443:13;4427:7;;:12;:29;;;;;;;;:::i;:::-;;4423:83;;4479:16;;-1:-1:-1;;;4479:16:4;;;;;;;;;;;4423:83;4357:155;:::o;14:127:57:-;75:10;70:3;66:20;63:1;56:31;106:4;103:1;96:15;130:4;127:1;120:15;146:252;213:4;207:11;;;245:17;;-1:-1:-1;;;;;277:34:57;;313:22;;;274:62;271:88;;;339:18;;:::i;:::-;375:4;368:24;146:252;:::o;403:745::-;445:5;498:3;491:4;483:6;479:17;475:27;465:55;;516:1;513;506:12;465:55;543:20;;-1:-1:-1;;;;;575:30:57;;572:56;;;608:18;;:::i;:::-;677:2;671:9;769:2;731:17;;-1:-1:-1;;727:31:57;;;760:2;723:40;719:54;707:67;;-1:-1:-1;;;;;789:34:57;;825:22;;;786:62;783:88;;;851:18;;:::i;:::-;887:2;880:22;911;;;952:19;;;973:4;948:30;945:39;-1:-1:-1;942:59:57;;;997:1;994;987:12;942:59;1061:6;1054:4;1046:6;1042:17;1035:4;1027:6;1023:17;1010:58;1116:1;1088:19;;;1109:4;1084:30;1077:41;;;;1092:6;403:745;-1:-1:-1;;;403:745:57:o;1153:1041::-;1237:6;1290:2;1278:9;1269:7;1265:23;1261:32;1258:52;;;1306:1;1303;1296:12;1258:52;1333:23;;-1:-1:-1;;;;;1368:30:57;;1365:50;;;1411:1;1408;1401:12;1365:50;1434:22;;1475:16;;;1511:4;1503:13;;1500:33;;;1529:1;1526;1519:12;1500:33;1555:17;;:::i;:::-;1592:4;1588:2;1584:13;1581:33;;;1610:1;1607;1600:12;1581:33;1638:17;;:::i;:::-;1623:32;;1692:2;1679:16;1726:1;1717:7;1714:14;1704:42;;1742:1;1739;1732:12;1704:42;1755:24;;1824:2;1816:11;;1803:25;1866:15;;1859:23;1847:36;;1837:64;;1897:1;1894;1887:12;1837:64;1930:2;1917:16;;1910:33;1952:22;;;2020:4;2012:13;;1999:27;;-1:-1:-1;;;;;2038:32:57;;2035:52;;;2083:1;2080;2073:12;2035:52;2119:44;2155:7;2144:8;2140:2;2136:17;2119:44;:::i;:::-;2114:2;2103:14;;2096:68;2107:5;1153:1041;-1:-1:-1;;;;;1153:1041:57:o;2199:127::-;2260:10;2255:3;2251:20;2248:1;2241:31;2291:4;2288:1;2281:15;2315:4;2312:1;2305:15","linkReferences":{}},"methodIdentifiers":{"assertExists(Variable)":"15af8fee"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"expected\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"actual\",\"type\":\"string\"}],\"name\":\"TypeMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"UnsafeCast\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum TypeKind\",\"name\":\"kind\",\"type\":\"TypeKind\"},{\"internalType\":\"bool\",\"name\":\"isArray\",\"type\":\"bool\"}],\"internalType\":\"struct Type\",\"name\":\"ty\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Variable\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"assertExists\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Ensures that when a `Variable` is cast to a concrete Solidity type, the operation is safe and the         underlying type matches what is expected.         Provides functions to check types, convert them to strings, and coerce `Variable` instances into         both single values and arrays of various types.         Usage example:         ```solidity         import {LibVariable} from \\\"./LibVariable.sol\\\";         contract MyContract {             using LibVariable for Variable;             StdConfig config;   // Assume 'config' is an instance of `StdConfig` and has already been loaded.             function readValues() public {                 // Retrieve a 'uint256' value from the config.                 uint256 myNumber = config.get(\\\"important_number\\\").toUint256();                 // Would revert with `TypeMismatch` as 'important_number' isn't a `uint256` in the config file.                 // string memory notANumber = config.get(\\\"important_number\\\").toString();                 // Retrieve a address array from the config.                 address[] memory admins = config.get(\\\"whitelisted_admins\\\").toAddressArray();          }      }      ```\",\"kind\":\"dev\",\"methods\":{\"assertExists(Variable)\":{\"details\":\"Checks if a `Variable` has been initialized, reverting if not.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for type-safe coercion of the `Variable` struct to concrete types.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/forge-std/src/LibVariable.sol\":\"LibVariable\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[\":forge-std/=lib/forge-std/src/\"]},\"sources\":{\"lib/forge-std/src/LibVariable.sol\":{\"keccak256\":\"0x1235f7ceab066656eb610bcb67a86163d1d65150fb43d949aaad6f9bbd36e7c7\",\"license\":\"MIT OR Apache-2.0\",\"urls\":[\"bzz-raw://752dde97fed2f5bcdacead4264d5bc8092091729182515c128862d556f736bae\",\"dweb:/ipfs/QmY67VxqWh4rSgub7cBjhTDWbM3dYiwBMs1jzQrEaAbCqe\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.30+commit.73712a01"},"language":"Solidity","output":{"abi":[{"inputs":[],"type":"error","name":"NotInitialized"},{"inputs":[{"internalType":"string","name":"expected","type":"string"},{"internalType":"string","name":"actual","type":"string"}],"type":"error","name":"TypeMismatch"},{"inputs":[{"internalType":"string","name":"message","type":"string"}],"type":"error","name":"UnsafeCast"},{"inputs":[{"internalType":"struct Variable","name":"self","type":"tuple","components":[{"internalType":"struct Type","name":"ty","type":"tuple","components":[{"internalType":"enum TypeKind","name":"kind","type":"TypeKind"},{"internalType":"bool","name":"isArray","type":"bool"}]},{"internalType":"bytes","name":"data","type":"bytes"}]}],"stateMutability":"pure","type":"function","name":"assertExists"}],"devdoc":{"kind":"dev","methods":{"assertExists(Variable)":{"details":"Checks if a `Variable` has been initialized, reverting if not."}},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":1},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/forge-std/src/LibVariable.sol":"LibVariable"},"evmVersion":"cancun","libraries":{}},"sources":{"lib/forge-std/src/LibVariable.sol":{"keccak256":"0x1235f7ceab066656eb610bcb67a86163d1d65150fb43d949aaad6f9bbd36e7c7","urls":["bzz-raw://752dde97fed2f5bcdacead4264d5bc8092091729182515c128862d556f736bae","dweb:/ipfs/QmY67VxqWh4rSgub7cBjhTDWbM3dYiwBMs1jzQrEaAbCqe"],"license":"MIT OR Apache-2.0"}},"version":1},"id":4}