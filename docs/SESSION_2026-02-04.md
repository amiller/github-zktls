# Session Notes - 2026-02-04

## What Was Built

### Agent Marketplace Escrow Demo
A bounty marketplace where buyers post tasks with ETH rewards, sellers claim via ZK proofs of tweets.

### Files Created

**Smart Contracts** (`zk-github-attestation/contracts/`):
```
src/
  ISigstoreVerifier.sol   - Interface (the standard)
  SigstoreVerifier.sol    - Implementation wrapping HonkVerifier
  HonkVerifier.sol        - Generated Honk verifier (100KB)
examples/
  SimpleEscrow.sol        - Basic escrow using ISigstoreVerifier
  AgentEscrow.sol         - Advanced escrow with AI judge
test/
  SigstoreVerifier.t.sol  - Tests (4/4 passing)
```

**ZK Circuit** (`zk-github-attestation/circuits-tweet/`):
- `src/main.nr` - Tweet attestation circuit (P-256 sig verify, hash checks)
- `Nargo.toml` - Circuit config

**Tweet Capture Workflow** (`.github/workflows/`):
- `tweet-capture.yml` - GitHub Actions workflow for capturing tweets with Sigstore attestation

**Witness Generator** (`zk-github-attestation/js/src/`):
- `tweet-witness.ts` - Generate circuit inputs from attestation bundles

**Judge Service** (`judge-service/`):
- `index.js` - Express server with Claude API for evaluating claims
- `package.json`, `.env.example`

**Frontend** (`frontend/`):
- `index.html` - Simple dApp for creating/browsing bounties

**Browser Container** (`browser-container/`):
- Updated extension for reliable Twitter login verification
- `TWITTER_VERIFICATION.md` - Documentation
- `test-tweet-capture.sh` - Local test script
- `verify-twitter-login.py` - (deprecated, use browser method)

## Key Decisions

### Twitter Login Verification
**Problem**: Need to verify browser session belongs to tweet author.

**Failed approaches**:
- DOM scraping for @mentions (unreliable)
- Twitter API v1.1 (deprecated)
- GraphQL endpoints (fragile)
- Python libraries (flaky)

**Working solution**: Use Twitter's `data-testid="AppTabBar_Profile_Link"` - stable because Twitter's QA uses it.

```javascript
const profileLink = document.querySelector('a[data-testid="AppTabBar_Profile_Link"]')
const username = profileLink.getAttribute('href').slice(1)
```

## Deployment

**Base Sepolia - SigstoreVerifier (canonical):**
- **SigstoreVerifier**: `0x0Af922925AE3602b0dC23c4cFCf54FABe2F54725`
- **HonkVerifier**: `0xf0542c61838D94B7D81dbE4eaEfA3687088384EC`
- Deployer: `0x5A370b73385085091de23E0fD21B54F2724EAD8D`
- Key stored: `~/.foundry/keystores/deployer.key`

**Libraries (Base Sepolia):**
- ZKTranscriptLib: `0xd317A58C478a18CA71BfC60Aab85538aB28b98ab`
- FrLib: `0x904Ae91989C4C96F2f51f1F8c9eF65C3730b3d8d`
- Honk: `0xE79cF62d6E87da1d776ab0b6F3d5f283c11b0435`
- HonkVerificationKey: `0xD0f2d9819F22b705163142d904f4384A2E0ceBbF`
- RelationsLib: `0x2cC4a1DD9190f6522824805a9951D2F0b3f770C2`
- CommitmentSchemeLib: `0xb9CB8dF5252922f31Ff76BF4cD5A5e1F77724ccf`

Explorer: https://sepolia.basescan.org/address/0x0Af922925AE3602b0dC23c4cFCf54FABe2F54725

**GitHubFaucet (Base Sepolia):**
- **GitHubFaucet**: `0xcfb53ce24F4B5CfA3c4a70F559F60e84C96bf863`
- Uses SigstoreVerifier for proof verification
- 1 claim per day per repo, min(0.001 ETH, balance/20)
- Explorer: https://sepolia.basescan.org/address/0xcfb53ce24F4B5CfA3c4a70F559F60e84C96bf863

**Old (deprecated):**
- AgentEscrow: `0xCaf55AE557b6a92D1B72AfeFf59a0C42D830736E`

## Test Results

```
forge test -vv
13 passed, 0 failed
```

All tests passing. (Fixed: was using precompile addresses 0x1-0x3 which can't receive ETH)

## P-384 Certificate Chain Verification (Added)

**Problem**: Sigstore leaf certificates are ephemeral (~10 min TTL). Bounty escrows need to accept proofs from future certificates.

**Solution**: Verify the certificate chain in-circuit using hardcoded Sigstore intermediate public key.

**Certificate Chain**:
```
Sigstore Root (P-384) - self-signed, 10 year validity
        |
        v
Sigstore Intermediate (P-384) - hardcoded in circuit, valid until Oct 2031
        |
        v  [VERIFIED IN CIRCUIT - ecdsa-with-SHA384]
Leaf Certificate (P-256) - ephemeral, ~10 min TTL
        |
        v  [VERIFIED IN CIRCUIT - ecdsa-with-SHA256]
Attestation (PAE envelope)
```

**Implementation**:
- Used zkpassport's `bignum`, `ecdsa`, `bigcurve` libraries for P-384
- Used zkpassport's `sha512` library for SHA-384 hashing
- Hardcoded Sigstore intermediate P-384 pubkey (X and Y coords)
- Circuit extracts leaf P-256 pubkey from TBS at witness-provided offset

**Circuit Stats**:
- Expression Width: 303,679
- ACIR Opcodes: 256,771
- Output Size: 10.8 MB

## Testing Results

**Witness Generation: SUCCESS**
```
Cert chain valid (P-384): true
Leaf signature valid (P-256): true
```

**Circuit Execution: SUCCESS**
```
[zk_github_attestation] Circuit witness successfully solved
[zk_github_attestation] Witness saved to target/zk_github_attestation.gz
```

**Proof Generation: SUCCESS**
```
bb 3.0.3 via Docker (host glibc too old for nightly)
Scheme: ultra_honk
Proving key computed in ~2s
Proof verified successfully
```

**Solidity Verifier: GENERATED**
- `SigstoreVerifier.sol` - 100KB, 2500 lines
- Contract: `HonkVerifier`
- Interface: `verify(bytes calldata proof, bytes32[] calldata publicInputs) returns (bool)`
- Compiles with forge (warnings only, no errors)

## bb Docker Setup

Host glibc (2.35) is too old for bb v4.x nightly. Solution: run bb in Docker.

```dockerfile
# Dockerfile.bb
FROM ubuntu:24.04
RUN apt-get update && apt-get install -y curl ca-certificates && rm -rf /var/lib/apt/lists/*
ARG BB_VERSION=v3.0.3
RUN curl -L -o /tmp/bb.tar.gz "https://github.com/AztecProtocol/aztec-packages/releases/download/${BB_VERSION}/barretenberg-amd64-linux.tar.gz" \
    && tar -xzf /tmp/bb.tar.gz -C /usr/local/bin && rm /tmp/bb.tar.gz && chmod +x /usr/local/bin/bb
WORKDIR /circuit
ENTRYPOINT ["bb"]
```

```bash
# Build image
docker build -f Dockerfile.bb -t bb:3.0.3 .

# Generate vk (with EVM target for Solidity verifier)
docker run --rm -v "$(pwd)/target:/circuit" bb:3.0.3 write_vk -b /circuit/zk_github_attestation.json -o /circuit/vk -t evm

# Generate proof
docker run --rm -v "$(pwd)/target:/circuit" bb:3.0.3 prove -b /circuit/zk_github_attestation.json -w /circuit/zk_github_attestation.gz -k /circuit/vk/vk -o /circuit/proof -t evm

# Verify proof
docker run --rm -v "$(pwd)/target:/circuit" bb:3.0.3 verify -k /circuit/vk/vk -p /circuit/proof/proof -i /circuit/proof/public_inputs -t evm

# Generate Solidity verifier
docker run --rm -v "$(pwd)/target:/circuit" bb:3.0.3 write_solidity_verifier -k /circuit/vk/vk -o /circuit/SigstoreVerifier.sol -t evm
```

## On-Chain Verification Test

```bash
forge script script/TestOnChain.s.sol --rpc-url https://sepolia.base.org
```

**Result: SUCCESS**
```
Proof length: 10560
Public inputs count: 84
Result: true
Artifact hash: 0x0ff929f1e9d16da57fb6fea24557fe429230e1bc52bb8f63077a2cd713dd2539
Repo hash: 0x2f8a31388a593dc718094b523b7b24d70e55abe4779ed5768ba96e027809e96b
Commit SHA: 0x49eb0a573214e2b35e9b5c95eaad7e2770d12159
```

## Documentation Rewrite

Repositioned the repo as a **standard/advisory** rather than an opinionated product.

**New README structure:**
- For Verifiers: How to evaluate proofs (two modes: trust prover vs audit workflow)
- For Provers: Fork repo, run workflow, generate proof
- Trust model diagram
- Contract interface

**New docs created:**
- `docs/auditing-workflows.md` - Guide for verifiers to evaluate workflow code
- `docs/generating-proofs.md` - Step-by-step proof generation guide
- `docs/trust-model.md` - What the proof guarantees vs what verifier must check

**Workflow templates:**
- `workflows/file-hash.yml` - Simple file attestation
- `workflows/tweet-capture.yml` - Tweet ownership proof with login verification

**Key insight:** The proof guarantees "repo X at commit Y produced artifact Z" - but whether to trust the workflow is the verifier's decision. The repo teaches both sides how to evaluate/create workflows.

## Private Key Management

**Deployer key stored at:** `~/.foundry/keystores/deployer.key`
- Address: `0x5A370b73385085091de23E0fD21B54F2724EAD8D`
- Can recover from: `~/.claude/projects/.../8cb74386...jsonl` logs

## Next Steps

1. ✅ **Deploy verifier contract** - SigstoreVerifier deployed to Base Sepolia
2. ✅ **Write documentation** - README, trust model, guides for provers/verifiers
3. **End-to-end test** - Full flow: fork repo → capture tweet → generate proof → claim bounty
4. **Mainnet deployment** - When ready

## Key Files Modified

- `circuits/Nargo.toml` - Added zkpassport deps (ecdsa, bignum, bigcurve, sha512)
- `circuits/src/main.nr` - Added P-384 cert chain verification with hardcoded Sigstore intermediate
- `js/src/index.ts` - Updated witness generator for new circuit inputs

## Commands

```bash
# Run tests
cd zk-github-attestation/contracts
forge test -vv

# Local tweet capture test
cd browser-container
docker compose up -d
./test-tweet-capture.sh "https://x.com/user/status/123" "0xAddress" ./twitter-session.json

# Extract Twitter cookies
python3 extract-cookies.py chrome x.com -o browser-container/twitter-session.json
```

## Architecture

```
Buyer creates bounty → IPFS (prompt) + Contract (ETH)
                              ↓
Seller tweets → GitHub Actions (capture) → Sigstore attestation
                              ↓
Seller generates ZK proof → Submits claim to contract
                              ↓
AI Judge evaluates → Approves/Rejects → Funds transfer
```

---

## Session Part 2: Repo Refactoring & Faucet Demo

### Repository Restructure

Reorganized repo to be more cohesive. Lifted ZK flow to top level.

**Old structure:**
```
zk-github-attestation/
  circuits/
  contracts/
  js/
  workflows/
```

**New structure:**
```
/
├── zk-proof/                  # Prover-side tooling
│   ├── circuits/              # ZK circuit
│   ├── js/                    # Witness generator
│   ├── Dockerfile             # Unified prover image
│   └── Dockerfile.bb          # bb-only image
├── contracts/                 # On-chain verification
│   ├── src/                   # ISigstoreVerifier, SigstoreVerifier, HonkVerifier
│   └── examples/              # GitHubFaucet, SimpleEscrow, AgentEscrow
├── workflow-templates/        # Canonical workflows
│   ├── github-identity.yml    # Simple identity proof (no secrets)
│   ├── tweet-capture.yml      # Tweet ownership
│   └── file-hash.yml          # File attestation
├── browser-container/         # Browser automation
├── docs/                      # Documentation
├── examples/                  # Demo apps
│   ├── workflows/             # 13 example workflows
│   ├── frontend/
│   ├── judge-service/
│   └── leaderboard/
└── README.md
```

**Changes:**
- `archive/` removed from git tracking (gitignored)
- Old `zk-github-attestation/` contents lifted to root
- Demo workflows moved to `examples/workflows/`
- Utility scripts consolidated

### GitHubFaucet Contract

New demo: testnet faucet that distributes ETH to unique GitHub repos.

**Contract:** `contracts/examples/GitHubFaucet.sol`
- 1 claim per day per repoHash (Sybil resistant)
- Claim amount: `min(0.001 ETH, balance/20)`
- Uses SigstoreVerifier for proof verification
- No required repo/commit (accepts any valid proof)

**Deployed:** `0xcfb53ce24F4B5CfA3c4a70F559F60e84C96bf863`
- Verified on Blockscout: https://base-sepolia.blockscout.com/address/0xcfb53ce24f4b5cfa3c4a70f559f60e84c96bf863
- Funded with 0.00005 ETH (needs more for real use)

### GitHub Identity Workflow

New workflow template: `workflow-templates/github-identity.yml`
- Proves GitHub account ownership
- No secrets required - just fork and run
- Inputs: `recipient_address`, `faucet_address`
- Outputs certificate with `github_actor`, `github_repository`

### Unified Docker Prover

Created `zk-proof/Dockerfile` - single image for complete proof generation:

```bash
docker build -t zkproof zk-proof/
docker run --rm -v $(pwd):/work zkproof generate /work/bundle.json /work/proof
```

Features:
- Includes nargo, bb, node
- Pre-compiles circuit and generates VK
- Single `zkproof generate` command
- Outputs: `proof.bin`, `inputs.bin`, `proof.hex`, `inputs.json`

### Faucet Claim Test

Successfully tested end-to-end claim:

```
Proof length: 10560
Public inputs count: 84
Faucet balance: 50000000000000 wei
Claim amount: 2500000000000 wei (balance/20)
Recipient before: 37567498899973 wei
Recipient after: 40067498899973 wei
Claim successful!
```

**Second claim correctly rejected:** `"Already claimed today"`

### README Rewrite

Rewrote README with faucet as the main hook:
- "Prove you ran code on GitHub. Verify on-chain. Get paid."
- Step-by-step faucet claim instructions
- Requirements: Docker only
- Clear prover/verifier sections
- Trust model summary

### Updated Commands

```bash
# New repo structure
cd /home/amiller/projects/teleport/github-zktls

# Run contract tests
cd contracts && forge test -vv

# Build unified prover
cd zk-proof && docker build -t zkproof .

# Generate proof from attestation
docker run --rm -v $(pwd):/work zkproof generate /work/bundle.json /work/proof

# Claim from faucet
forge script script/ClaimFaucet.s.sol --rpc-url https://sepolia.base.org --broadcast
```

### Next Steps

1. ✅ **Repo refactoring** - Clean structure with zk-proof/, contracts/, workflow-templates/
2. ✅ **Faucet demo** - GitHubFaucet deployed and tested
3. ✅ **Unified Docker** - Single command proof generation
4. **Fund faucet** - Needs more ETH for real use
5. **End-to-end GitHub Actions test** - Run github-identity.yml, generate proof, claim
6. **Publish Docker image** - Push to ghcr.io for easier use
